import numpy as np
from scipy.optimize import curve_fit

from sys import exit
import time
from datetime import datetime
import pandas as pd
import os
import threading

from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.colors import LinearSegmentedColormap

from Drivers.Leonardo import *
from Drivers.Yokogawa import *
from Drivers.LakeShore import *
from Lib import FieldUtils
from Lib.lm_utils import *


# User input
# ------------------------------------------------------------------------------------------------------------
k_A, k_V_meas, k_R, R, rangeA, stepA, gain, step_delay, num_samples, I_units, V_units, f_save, yok_read, yok_write, ls, user_params = ParseCommandLine()
Log = Logger(R, k_R, 'B')
Log.AddGenericEntry(
    f'CurrentRange={(rangeA / R) / k_A} {core_units[k_A]}A; CurrentStep={(stepA / R) / k_A} {core_units[k_A]}A; '
    f'Gain={gain}; IVPointDelay={step_delay} sec; LeonardoPoints={num_samples}')
# ------------------------------------------------------------------------------------------------------------

# Initialize devices
# ------------------------------------------------------------------------------------------------------------
Leonardo = LeonardoMeasurer(n_samples=num_samples)
Yokogawa_I = YokogawaMeasurer(device_num=yok_read, dev_range='1E+1', what='VOLT')
Yokogawa_B = YokogawaMeasurer(device_num=yok_write, dev_range='2E-1', what='CURR')  # range in mA
LakeShore = LakeShoreController(device_num=ls, mode='passive')
# ------------------------------------------------------------------------------------------------------------

# Yokogawa voltage values (will be generated by Yokogawa 1) (always V!!!)
n_points = int(2 * rangeA // stepA)
upper_line_1 = np.linspace(0, rangeA, n_points // 2)
down_line_1 = np.linspace(rangeA, -rangeA, n_points)
upper_line_2 = np.linspace(-rangeA, 0, n_points // 2)
voltValues0 = np.hstack((upper_line_1,
                         down_line_1,
                         upper_line_2))

# Solenoid current values (will be generated by Yokogawa 2) (always mA!!!)
try:
    rangeA_B, stepA_B = [FieldUtils.B_to_I(float(i)) for i in user_params.split(';')]
except Exception:  # default value if params are not specified in command-line
    rangeA_B = 200  # mA
    stepA_B = 50  # mA
    print('Using default values: ')
print('Field sweep range: +-', FieldUtils.I_to_B(rangeA_B), 'G', 'step is', FieldUtils.I_to_B(stepA_B), 'G')
n_points_B = int(rangeA_B // stepA_B)
down_line_1B = np.linspace(0, -rangeA_B, int(n_points_B//2))
upper_line_1B = np.linspace(-rangeA_B, rangeA_B, n_points_B)
down_line_2B = np.linspace(rangeA_B, 0, int(n_points_B//2))


# Custom plot colormaps
R_3D_colormap = LinearSegmentedColormap.from_list("R_3D", [(0, 0, 1), (1, 1, 0), (1, 0, 0)])

# Resistance measurement
# ----------------------------------------------------------------------------------------------------
percentage_R = 0.1  # how many percents left-right will be used to measure R
fraction_R = int(len(voltValues0) * ((1 / 3) * 2 * percentage_R))  # in how many points R will be measured
lower_R_bound = upper_line_2[int(len(upper_line_2) * percentage_R)]
upper_R_bound = upper_line_1[int(len(upper_line_1) * (1 - percentage_R))]
# ------------------------------------------------------------------------------------------------------------

# data receiver
N_points = len(down_line_1)
data_buff_C = np.zeros((N_points, len(upper_line_1B)))
data_buff_R = np.zeros((N_points, len(upper_line_1B)))
R_buff_C = np.zeros((N_points, len(upper_line_1B)))
R_buff_R = np.zeros((N_points, len(upper_line_1B)))
currValues = []
fieldValues = []
voltValues = []
currValues_axis = ((-down_line_1 / R) / k_A)
fieldValues_axis = FieldUtils.I_to_B(upper_line_1B)
tempsMomental = []  # for temperatures plot

# behavior on program exit - save data
f_exit = threading.Event()

# remaining / estimated time
time_mgr = TimeEstimator(len(fieldValues_axis))


def DataSave():
    if not f_save:
        return
    pw.ShowTitle('')
    caption = 'B'

    SaveData({'B, Gs': fieldValues, f'I, {I_units}A': currValues,
              f'U, {I_units}V': voltValues, 'R': np.gradient(voltValues)},
             R, caption=caption, k_A=k_A, k_V_meas=k_V_meas, k_R=k_R)

    print('Saving PDF...')
    fname = GetSaveFileName(R, k_R, caption, 'pdf')
    pp = PdfPages(fname[:-3] + 'pdf')
    pw.SaveFigureToPDF(tabIVBCMesh, pp)
    pw.SaveFigureToPDF(tabIVBRMesh, pp)
    pw.SaveFigureToPDF(tabIVBC3D, pp)
    pw.SaveFigureToPDF(tabIVBR3D, pp)
    pw.SaveFigureToPDF(tabIRBCMesh, pp)
    pw.SaveFigureToPDF(tabIRBRMesh, pp)
    pw.SaveFigureToPDF(tabIRBC3D, pp)
    pw.SaveFigureToPDF(tabIRBR3D, pp)
    pp.close()
    print('Plots were successfully saved to PDF:', fname)

    SaveMatrix(fieldValues, currValues, voltValues, f'I, {I_units}A', R, k_R, caption=caption)
    Log.Save()

pw = plotWindow("Leonardo I-U measurement with different T")

# 0) Colormesh I-V-T plot preparation, crit. curr
tabIVBCMesh = pw.addColormesh('I-U-B (Color mesh) (crit.)', '$B, Gs$', fr"$I, {core_units[k_A]}A$",
                                   fieldValues_axis, currValues_axis, data_buff_C, plt.get_cmap('brg'))

# 1) Colormesh I-V-T plot preparation, ret. curr
tabIVBRMesh = pw.addColormesh('I-U-B (Color mesh) (retr.)', '$B, Gs$', fr"$I, {core_units[k_A]}A$",
                                    fieldValues_axis, currValues_axis, data_buff_R, plt.get_cmap('brg'))

# 2) I-V 2D plot preparation, crit. curr
tabIV = pw.addLine2D('I-U (simple 2D)', fr'$I, {core_units[k_A]}A$', fr"$U, {core_units[k_V_meas]}V$")

# 3) I-V-B 3D plot, crit. curr
tabIVBC3D = pw.add3DPlot('I-U-B (3D) (crit.)', 'B, Gs', fr'I, {core_units[k_A]}A', fr'$U, {core_units[k_V_meas]}V$')

# 4) I-V-T 3D plot, retr. curr
tabIVBR3D = pw.add3DPlot('I-U-B (3D) (retr.)', 'B, Gs', fr'I, {core_units[k_A]}A', fr'$U, {core_units[k_V_meas]}V$')

# 5) T - I - R 2D colormesh plot, crit. curr
tabIRBCMesh = pw.addColormesh('I-R-B (Color mesh) (crit.)', '$B, Gs$', fr"$I, {core_units[k_A]}A$",
                              fieldValues_axis, currValues_axis, R_buff_C, R_3D_colormap)

# 6) T - I - R 2D colormesh plot, ret. curr
tabIRBRMesh = pw.addColormesh('I-R-B (Color mesh) (retr.)', '$B, Gs$', fr"$I, {core_units[k_A]}A$",
                                      fieldValues_axis, currValues_axis, R_buff_R, R_3D_colormap)

####################

# 7) T - I - R 3D plot, crit. curr
tabIRBC3D = pw.add3DPlot('I-R-B (3D) (crit.)', 'B, Gs', fr'I, {core_units[k_A]}A', fr'$R, Ohm$')

# 8) T - I - R 3D plot, retr. curr
tabIRBR3D = pw.add3DPlot('I-R-B (3D) (retr.)', 'B, Gs', fr'I, {core_units[k_A]}A', fr'$R, Ohm$')

# 9) T(t) plot - to control temperature in real time
tabTemp = pw.addLine2D('Temperature', 'Time', 'T, mK')
times = []
t = 0


def UpdateRealtimeThermometer():
    global times, tempsMomental, LakeShore, t, pw
    T_curr = LakeShore.GetTemperature()
    times.append(t)
    t += 1
    tempsMomental.append(T_curr)
    if t > 1000:
        tempsMomental = tempsMomental[-1000:]  # keep memory and make plot to move left
        times = times[-1000:]

    if pw.CurrentTab == tabTemp:
        line_T = pw.CoreObjects[tabTemp]
        axT = pw.Axes[tabTemp]
        line_T.set_xdata(times)
        line_T.set_ydata(tempsMomental)
        axT.set_xlim(times[0], times[-1])  # remove green/red points which are below left edge of plot
        axT.autoscale_view()
        axT.set_title(f'T={T_curr}')
        pw.canvases[tabTemp].draw()


def TemperatureThreadProc():
    while not f_exit.is_set():
        UpdateRealtimeThermometer()
        time.sleep(1.5)


def EquipmentCleanup():
    print('Returning magnetic field to zero...')
    FieldUtils.ReturnAtExit(Yokogawa_B, pw)
    Yokogawa_B.SetOutput(0)
    Yokogawa_I.SetOutput(0)


# main thread - runs when PyQt5 application is started
curr_curr = 0


@MeasurementProc(EquipmentCleanup)
def thread_proc():
    global Leonardo, Yokogawa_I, Yokogawa_B, LakeShore, pw, f_exit, currValues, voltValues, fieldValues, tempsMomental, curr_curr

    # Slowly change: 0 -> min. field
    FieldUtils.SlowlyChange(Yokogawa_B, pw, np.linspace(0, -rangeA_B, 15), 'prepairing...')

    print('Measurement begin')

    for i, curr_B in enumerate(upper_line_1B):
        time_mgr.OneSweepStepBegin()

        FieldUtils.SetField(Yokogawa_B, curr_B)

        Log.AddParametersEntry('B', curr_B, 'G', temp=tempsMomental[-1])

        # Mark measurement begin
        UpdateRealtimeThermometer()
        pw.MarkPointOnLine(tabTemp, times[-1], tempsMomental[-1], 'go', markersize=4)
        this_field_V = []  # for I-V 2D plot
        this_field_A = []

        this_RIValues = [0]  # for resistance measurement
        this_RUValues = [0]

        pw.SetHeader(tabIV, 'R will be measured later...')

        def PerformStep(yok, currValues, fieldValues, voltValues,
                        volt, this_field_V, this_field_A, this_B, this_RIValues, this_RUValues):
            # measure I-U curve
            yok.SetOutput(volt)
            time.sleep(step_delay)
            curr_curr = (volt / R) / k_A
            V_meas = Leonardo.MeasureNow(6) / gain

            result = V_meas / k_V_meas
            currValues.append(curr_curr)
            fieldValues.append(this_B)
            voltValues.append(V_meas / k_V_meas)
            this_field_V.append(V_meas / k_V_meas)
            this_field_A.append(curr_curr)

            status_message = f'I={curr_curr:.4f} {I_units}A, V={result:.4f} {V_units}V, B={FieldUtils.I_to_B(curr_B):.4f} Gs'
            pw.ShowTitle(status_message)

            pw.MouseInit(tabIVBR3D)
            pw.MouseInit(tabIVBC3D)
            pw.MouseInit(tabIRBR3D)
            pw.MouseInit(tabIRBC3D)

            # Update I-U 2D plot
            if pw.CurrentTab == tabIV:
                pw.updateLine2D(tabIV, this_field_A, this_field_V)

            # measure resistance on 2D plot
            if volt > upper_R_bound:
                this_RIValues.append(curr_curr)
                this_RUValues.append(V_meas / k_V_meas)
                if pw.CurrentTab == tabIV:
                    UpdateResistance(ax2, this_RIValues, this_RUValues)

            if f_exit.is_set():
                exit(0)

            return result

        # 1/3: 0 - max curr, Ic+
        for j, volt in enumerate(upper_line_1):
            res = PerformStep(Yokogawa_I, currValues, fieldValues, voltValues,
                              volt, this_field_V, this_field_A, curr_B, this_RIValues, this_RUValues)
            data_buff_C[j + N_points // 2, i] = res

        # 2/3: max curr -> min curr, Ir+, Ic-
        for j, volt in enumerate(down_line_1):
            res = PerformStep(Yokogawa_I, currValues, fieldValues, voltValues,
                              volt, this_field_V, this_field_A, curr_B, this_RIValues, this_RUValues)
            if j < (len(down_line_1) // 2):
                data_buff_R[N_points - j - 1, i] = res
            else:
                data_buff_C[N_points - j - 1, i] = res

        # 3/3: max curr -> min curr, Ir-
        for j, volt in enumerate(upper_line_2):
            res = PerformStep(Yokogawa_I, currValues, fieldValues, voltValues,
                              volt, this_field_V, this_field_A, curr_B, this_RIValues, this_RUValues)
            data_buff_R[j, i] = res

        # Update 3D plot - every magnetic field value
        pw.update3DPlot(tabIVBC3D, fieldValues_axis[:i + 1], currValues_axis, data_buff_C[:, :i + 1],
                        fieldValues_axis, plt.cm.brg)
        #
        pw.update3DPlot(tabIVBR3D, fieldValues_axis[:i + 1], currValues_axis, data_buff_R[:, :i + 1],
                        fieldValues_axis, plt.cm.brg)

        # update pcolormesh (tab 1, 2)
        pw.updateColormesh(tabIVBCMesh, data_buff_C, fieldValues_axis, currValues_axis, 9)
        pw.updateColormesh(tabIVBRMesh, data_buff_R, fieldValues_axis, currValues_axis, 9)

        # calculate R values (as dV/dI)
        R_values_C = np.gradient(np.array(data_buff_C[:, i]) * k_V_meas)  # V in volts, to make R in ohms
        R_buff_C[:, i] = R_values_C
        #
        R_values_R = np.gradient(np.array(data_buff_R[:, i]) * k_V_meas)  # V in volts, to make R in ohms
        R_buff_R[:, i] = R_values_R

        # update R color mesh with these values
        pw.updateColormesh(tabIRBCMesh, R_buff_C, fieldValues_axis, currValues_axis, 9)
        pw.updateColormesh(tabIRBRMesh, R_buff_R, fieldValues_axis, currValues_axis, 9)

        # update R 3D plot
        pw.update3DPlot(tabIRBC3D, fieldValues_axis[:i + 1], currValues_axis, R_buff_C[:, :i + 1],
                        fieldValues_axis, R_3D_colormap)
        pw.update3DPlot(tabIRBR3D, fieldValues_axis[:i + 1], currValues_axis, R_buff_R[:, :i + 1],
                        fieldValues_axis, R_3D_colormap)

        # Mark measurement end
        pw.MarkPointOnLine(tabTemp, times[-1], tempsMomental[-1], 'ro', markersize=4)

        time_mgr.OneSweepStepEnd(i + 1)
    
    FieldUtils.ReturnAtExit(Yokogawa_B, pw)


gui_thread = threading.Thread(target=thread_proc)
gui_thread.start()

thermometer_thread = threading.Thread(target=TemperatureThreadProc)
thermometer_thread.start()

pw.show()  # show main tabbed window

# if exited before current returned to zero
FieldUtils.CheckAtExit(Yokogawa_B, pw)

f_exit.set()
DataSave()

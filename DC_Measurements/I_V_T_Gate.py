import numpy as np
from scipy.optimize import curve_fit
from sys import exit
import threading
import pickle
from matplotlib import pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

from Drivers.Leonardo import *
from Drivers.Yokogawa import *
from Drivers.LakeShore370 import *
from Drivers.Keithley2182A import *
from Drivers.Keithley6200 import *

from Lib.lm_utils import *

# User input
# ------------------------------------------------------------------------------------------------------------
k_A, k_V_meas, k_R, R, rangeA, stepA, gain, step_delay, num_samples, I_units, V_units, f_save, yok_read, yok_write, \
    ls, ls_model, read_device_type, exc_device_type, read_device_id, user_params = ParseCommandLine()
Log = Logger(R, k_R, 'Ic_Vg_T')
Log.AddGenericEntry(
    f'CurrentRange={(rangeA / R) / k_A} {core_units[k_A]}A; CurrentStep={(stepA / R) / k_A} {core_units[k_A]}A; '
    f'Gain={gain}; IVPointDelay={step_delay} sec; LeonardoPoints={num_samples}')
# ------------------------------------------------------------------------------------------------------------

# Initialize parameters
# get LakeShore temperature sweep parameters
try:
    temp0, max_temp, temp_step, gate_range, gate_points = [float(i) for i in user_params.split(';')]
    if temp0 == 0:
        temp0 = None  # if 0 specified in a command-line, use current LakeShore temperature as starter in sweep
except Exception:
    temp0, max_temp, temp_step = None, 1.1, 100 * 1E-3
    gate_range, gate_points = 1.3, 10
print(f'Temperature sweep range: from {"<current>" if temp0 is None else temp0*1e+3} mK to {max_temp} K, with step: {temp_step*1e+3:.3f} mK')
print('Gate voltages range:', gate_range, 'V, gate swept points:', gate_points)

# Initialize devices
# ------------------------------------------------------------------------------------------------------------
Leonardo = Leonardo(n_samples=num_samples) if read_device_type == READOUT_LEONARDO \
    else Keithley2182A(device_num=read_device_id)
Yokogawa_I = YokogawaGS200(device_num=yok_read, dev_range='1E+1', what='VOLT') if exc_device_type == EXCITATION_YOKOGAWA \
    else Keithley6200(device_num=yok_read, what='VOLT', R=R)
Yokogawa_V = YokogawaGS200(device_num=yok_write, dev_range='1E+1', what='VOLT')
LakeShore = LakeShore370(device_num=ls, step=200 * 1E-3)
print('Temperatures will be:\n', LakeShore.TempRange)

# Yokogawa voltage values
N_pointsOne = int(2 * rangeA // stepA)
upper_line_1 = np.linspace(0, rangeA, N_pointsOne // 2)
down_line_1 = np.linspace(rangeA, -rangeA, N_pointsOne)
upper_line_2 = np.linspace(-rangeA, 0, N_pointsOne // 2)
voltValues0 = np.hstack((upper_line_1,
                         down_line_1,
                         upper_line_2))
N_points = len(voltValues0)
allCurrents = (voltValues0 / R) / k_A

# Gate voltage values values (will be generated by Yokogawa 2) (always V!!!)
N_gates = int(gate_points)
voltValuesGate = np.linspace(-gate_range, gate_range, N_gates)

all_temperatures = LakeShore.TempRange
N_temps = len(all_temperatures)

# Resistance measurement
# ----------------------------------------------------------------------------------------------------------------------
percentage_R = 0.1  # how many percents left-right will be used to measure R
fraction_R = int(len(voltValues0) * ((1 / 3) * 2 * percentage_R))  # in how many points R will be measured
lower_R_bound = upper_line_2[int(len(upper_line_2) * percentage_R)]
upper_R_bound = upper_line_1[int(len(upper_line_1) * (1 - percentage_R))]
# ----------------------------------------------------------------------------------------------------------------------

core_buffer = np.zeros((N_gates, N_temps))

f_exit = threading.Event()
# remaining / estimatsd time
time_mgr = TimeEstimator(N_gates)

pw = plotWindow('Ic - T with different gate values')
fig_main, ax_main = pw.addEmptyLine2D('Ic(T)', 'T, K', fr'$I_C$, ${core_units[k_A]}A$')
fig_IV, ax_IV, line_IV = pw.addLine2D('I-V',  fr'$I, {core_units[k_A]}A$', fr"$U, {core_units[k_V_meas]}V$")
fig_T, ax_T, line_T = pw.addLine2D('Temperature', 'Time', 'T, K')

# -----------------------------------Update T on the last tab-----------------------------------------------------------
t = 0
times = []
tempsMomental = []  # for temperatures plot


def UpdateRealtimeThermometer():
    global times, tempsMomental, LakeShore, ax_T, line_T, t, pw
    T_curr = LakeShore.GetTemperature()
    times.append(t)
    t += 1
    tempsMomental.append(T_curr)
    if t > 1000:
        tempsMomental = tempsMomental[-1000:]  # keep memory and make plot to move left
        times = times[-1000:]

    if pw.CurrentTab == 2:
        pw.updateLine2D(ax_T, line_T, times, tempsMomental)
        ax_T.set_xlim(times[0], times[-1])  # remove green/red points which are below left edge of plot
        ax_T.set_title(f'T={T_curr:.4f}')
        pw.canvases[-1].draw()


def TemperatureThreadProc():
    while not f_exit.is_set():
        UpdateRealtimeThermometer()
        time.sleep(1)
# ----------------------------------------------------------------------------------------------------------------------


def DataSave():
    main_caption = "Ic_Vg_T"

    try:
        simple_buffer = np.zeros((N_temps * N_meas_gates, 3))
        for ng, vgate in enumerate(voltValuesGate[:N_meas_gates]):
            for nt, temp in enumerate(all_temperatures):
                simple_buffer[ng * N_temps + nt, 0] = vgate
                simple_buffer[ng * N_temps + nt, 1] = temp
                simple_buffer[ng * N_temps + nt, 2] = core_buffer[ng, nt]

        df = pd.DataFrame(data=simple_buffer)
        fname = GetSaveFileName(R, k_R, caption=main_caption + 'Ic')
        df.to_csv(fname, sep=' ', index=False, header=['Vgate, V', 'T, K', fr'$I, {core_units[k_A]}A$'],
                  float_format='%.8f')
        print('Data were successfully saved to: ', fname)

        extended_buffer = []
        N_measured = len(IV_curves)
        f_resume = True
        for ng, vgate in enumerate(voltValuesGate[:N_meas_gates]):
            for nt, temp in enumerate(all_temperatures):
                now_number = ng * N_temps + nt
                if now_number >= N_measured:  # if last gate is measured not full (measurement aborted)
                    f_resume = False
                    break
                now_curve = IV_curves[now_number]
                IV = np.column_stack((allCurrents, now_curve))
                IVTGate = np.column_stack(([temp] * N_points, [vgate] * N_points, IV))
                extended_buffer.append(IVTGate)
            if not f_resume:
                break
        extended_buffer = np.vstack(extended_buffer)

        df = pd.DataFrame(data=extended_buffer)
        fname = GetSaveFileName(R, k_R, caption=main_caption)
        df.to_csv(fname, sep=' ', index=False, header=['T, K', 'Vgate, V', fr'$I, {core_units[k_A]}A$',
                                                       fr"$U, {core_units[k_V_meas]}V$"], float_format='%.8f')

        print('Data were successfully saved to: ', fname)
        # upload to cloud services
        UploadToClouds(GetSaveFolder(R, k_R, main_caption))
        Log.Save()
    except Exception:  # to avoid data loss when an error occured
        fname = GetSaveFileName(R, k_R, caption=main_caption + 'CrashDump', ext='pickle')
        dict_save = {'IVCurves:': IV_curves, 'Temps': all_temperatures, 'Vgates': voltValuesGate,
                     'Currents': allCurrents}
        print('Error saving data, all measured values dumped into: ', fname)
        with open(fname, 'wb') as f:
            pickle.dump(dict_save, f)

    fname_pdf = GetSaveFileName(R, k_R, caption=main_caption, ext='pdf')
    pp = PdfPages(fname_pdf)
    pp.savefig(fig_main)
    pp.close()
    print('Plots were successfully saved to: ', fname_pdf)


# data receivers
IV_curves = []
N_meas_gates = 0
N_meas_temps = 0


def EquipmentCleanup():
    Yokogawa_I.SetOutput(0)
    Yokogawa_V.SetOutput(0)
    del LakeShore


@MeasurementProc(EquipmentCleanup)
def MainThreadProc():
    global IV_curves, N_meas_gates, N_meas_temps
    # Temperature change and measures process!

    for j, vgate in enumerate(voltValuesGate):
        Yokogawa_V.SetOutput(vgate)
        N_meas_gates += 1
        this_line, = ax_main.plot([], [], linestyle='-', marker='o', label=f'$V_G$ = {vgate:.5f}')

        for i, temp in enumerate(LakeShore):
            ax_main.set_title(fr'Now measuring $V_G$ = {vgate:.5f}, T={temp:.4f} K')
            # try to measure while temperature will be stable
            fMeasSuccess = False
            this_T = []

            Log.AddParametersEntry('T', temp, 'K', Vgate=vgate, PID=LakeShore.pid, HeaterRange=LakeShore.htrrng,
                                   Excitation=LakeShore.excitation)

            while not fMeasSuccess:
                # Measure some Ic with different Vg at this temperature
                # Mark measurement begin
                UpdateRealtimeThermometer()
                ax_T.plot(times[-1], [tempsMomental[-1]], 'go', markersize=4)

                I_values = []
                U_values = []
                I_values_R = []
                U_values_R = []

                # calculate estimated time
                time_mgr.OneSweepStepBegin()

                this_T.append(tempsMomental[-1])

                # measure one I-V curve
                def PerformStep(yok,  currValues, voltValues, volt, this_RIValues, this_RUValues):
                    # measure I-U curve
                    yok.SetOutput(volt)
                    time.sleep(step_delay)
                    curr_curr = (volt / R) / k_A
                    V_meas = Leonardo.MeasureNow(6) / gain
                    result = V_meas / k_V_meas

                    currValues.append(curr_curr)
                    voltValues.append(V_meas)

                    pw.updateLine2D(ax_IV, line_IV, currValues, voltValues)
                    pw.canvases[1].draw()

                    return result

                if f_exit.is_set():
                    exit(0)

                # 1/3: 0 - max curr
                f_crit = False
                Ip_crit = 0
                for k, volt in enumerate(upper_line_1):
                    res = PerformStep(Yokogawa_I, I_values, U_values, volt, I_values_R, U_values_R)
                    if (res * k_V_meas) > 1 * 1e-6 and not f_crit:
                        f_crit = True
                        Ip_crit = (volt / R) / k_A

                # 2/3: max curr -> min curr
                f_crit = False
                Im_crit = 0
                for k, volt in enumerate(down_line_1):
                    res = PerformStep(Yokogawa_I, I_values, U_values, volt, I_values_R, U_values_R)
                    if volt < 0 and res * k_V_meas > 1 * 1e-6 and not f_crit:
                        f_crit = True
                        Im_crit = (volt / R) / k_A

                # 3/3: max curr -> min curr
                for k, volt in enumerate(upper_line_2):
                    res = PerformStep(Yokogawa_I, I_values, U_values, volt, I_values_R, U_values_R)

                # Mark measurement end
                ax_T.plot(times[-1], [tempsMomental[-1]], 'ro', markersize=4)

                # write obtained Ic values
                core_buffer[j, i] = Ip_crit

                # write I(V) curve to common array
                IV_curves.append(U_values)

                # plot measured curve
                curve = core_buffer[j, :i+1]
                pw.updateLine2D(ax_main, this_line, all_temperatures[:i+1], curve)
                ax_main.legend()
                pw.canvases[0].draw()

                # measurement end, check
                mean_temp = np.mean(this_T)
                if abs(mean_temp - temp) > 0.005:  # toleracy is 5 mK
                    print(f'Temperature was unstable, desired - {temp}, average - {mean_temp}. Now retrying...')

                    # Erase now measured data
                    # erase I-V curve from a global buffer
                    IV_curves = IV_curves[:-1]
                    # values in Ic (2D) buffer will just be owerwritten - i and j indices will be the same

                    # retry loop, do not exit while
                    fMeasSuccess = False
                else:
                    fMeasSuccess = True
                N_meas_temps += 1
                time_mgr.OneSweepStepEnd(j * N_temps + i)





thermometerThread = threading.Thread(target=TemperatureThreadProc)
thermometerThread.start()
mainThread = threading.Thread(target=MainThreadProc)
mainThread.start()

pw.show()
f_exit.set()
DataSave()
import numpy as np
from scipy.optimize import curve_fit
from matplotlib import pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from scipy.signal import savgol_filter

import os
import time
import threading
from copy import copy
from sys import exit

from Drivers.Leonardo import *
from Drivers.Yokogawa import *

from Lib import FieldUtils
from Lib.lm_utils import *


# Write temperature obtained from BlueFors log jnto a plot
# If it is not known now (no newest logs), write about it
def FormatTemperature(temp):
    return T if temp != 0 else '<...loading...>'


# User input
# ------------------------------------------------------------------------------------------------------------
k_A, k_V_meas, k_R, R, rangeA, stepA, gain, step_delay, num_samples, I_units, V_units, f_save, yok_read, yok_write, ls, user_params = ParseCommandLine()
Log = Logger(R, k_R, 'V_B')
Log.AddGenericEntry(
    f'CurrentRange={(rangeA / R) / k_A} {core_units[k_A]}A; CurrentStep={(stepA / R) / k_A} {core_units[k_A]}A; '
    f'Gain={gain}; IVPointDelay={step_delay} sec; LeonardoPoints={num_samples}')
# ------------------------------------------------------------------------------------------------------------

# Initialize devices
# ------------------------------------------------------------------------------------------------------------
Leonardo = LeonardoMeasurer(n_samples=num_samples)
Yokogawa_I = YokogawaMeasurer(device_num=yok_read, dev_range='1E+1', what='VOLT')
Field_controller = YokogawaMeasurer(device_num=yok_write, dev_range='2E-1', what='CURR')  # range in mA
# ------------------------------------------------------------------------------------------------------------

# Solenoid current values (will be generated by Yokogawa 2) (always mA!!!)
try:
    rangeA_B, stepA_B, bias_start, bias_end, bias_step = [float(i) for i in user_params.split(';')]
    rangeA_B = FieldUtils.B_to_I(rangeA_B)
    stepA_B = FieldUtils.B_to_I(stepA_B)
except Exception:  # default value if params are not specified in command-line
    rangeA_B = 200  # mA
    stepA_B = 50  # mA
    bias_start = 2.25  # mA
    bias_end = 2.69  # mA
    bias_step = 30  #V
    print('Using default values: ')
print('Field sweep range: +-', FieldUtils.I_to_B(rangeA_B), 'G,', 'step is', FieldUtils.I_to_B(stepA_B), 'G')
print(f'Bias current: from {bias_start} mkA to {bias_end} mkA, with step {bias_step}')
n_points_B = int(rangeA_B // stepA_B)
down_line_1B = np.arange(0, -rangeA_B, -stepA_B)
upper_line_1B = np.arange(-rangeA_B, rangeA_B, stepA_B)
down_line_2B = np.arange(rangeA_B, 0, -stepA_B)

# Current parameters
v0_sweep = np.linspace(bias_start*1E-6 * R, bias_end*1E-6 * R, int(bias_step)) # U=IR

# Measurement result
data_dict_inc = {}
data_dict_dec = {}

# Exit main thread when window closed
f_exit = threading.Event()

# Temperature (will be read from logs)
T = 0

# Remaining (estimated) time
time_mgr = TimeEstimator(len(v0_sweep))


# Save data after program exit
def DataSave():
    caption = "V_B"

    print('Saving PDF...')
    fname = GetSaveFileName(R, k_R, caption, 'pdf')
    pp = PdfPages(fname)
    pw.SaveAllToPDF(pp)
    pp.close()
    print('Plot was successfully saved to PDF:', fname)

    SaveData(data_dict_inc, R, caption=caption + "_forward", k_A=k_A, k_V_meas=k_V_meas, k_R=k_R)
    SaveData(data_dict_dec, R, caption=caption + "_reverse", k_A=k_A, k_V_meas=k_V_meas, k_R=k_R)

    Log.Save()

    # upload to cloud services
    UploadToClouds(GetSaveFolder(R, k_R, caption))


pw = plotWindow("V-B measurement", color_buttons=False)

tabVB = pw.addScatter2D('V-B (now)', "$B, Gs$", fr'$U, {core_units[k_V_meas]}V$', markersize=3)

tabVBForwardOffset = pw.addScatter2D('V-B, forward (with offset)', "$B, Gs$", fr'$U, {core_units[k_V_meas]}V$')

tabVBReverseOffset = pw.addScatter2D('V-B, reverse (with offset)', "$B, Gs$", fr'$U, {core_units[k_V_meas]}V$')

tabVBForwardNoOffset = pw.addScatter2D('V-B, forward (no offset)', "$B, Gs$", fr'$U, {core_units[k_V_meas]}V$')

tabVBReverseNoOffset = pw.addScatter2D('V-B, reverse (no offset)', "$B, Gs$", fr'$U, {core_units[k_V_meas]}V$')


def EquipmentCleanup():
    FieldUtils.ReturnAtExit(Field_controller, pw)
    Field_controller.SetOutput(0)
    Yokogawa_I.SetOutput(0)


@MeasurementProc(EquipmentCleanup)
def MainThreadProc():
    global curr_curr

    # Move current down, 0 => -A
    FieldUtils.SlowlyChange(Field_controller, pw, np.linspace(0, -rangeA_B, 15), 'prepairing...')

    # offset algorithm initialization
    min_pred_inc = max_pred_inc = 0
    min_pred_dec = max_pred_dec = 0
    gap = 0.02
    curr_plot_bias_inc = 0
    curr_plot_bias_dec = 0

    # "field" column in each data matrix
    data_dict_inc['B, Gs'] = FieldUtils.I_to_B(upper_line_1B)
    data_dict_dec['B, Gs'] = FieldUtils.I_to_B(upper_line_1B[::-1])

    # Measurement process
    # Sweep bias current
    for k, v0 in enumerate(v0_sweep):
        time_mgr.OneSweepStepBegin()
        Yokogawa_I.SetOutput(v0)

        # Magnetic field values: from - to +, then from + to -
        line_now = np.hstack((np.arange(-rangeA_B, rangeA_B, stepA_B), np.arange(rangeA_B, -rangeA_B, -stepA_B)))
        voltValues_inc = []
        voltValues_dec = []
        fieldValues_inc = []
        fieldValues_dec = []
        pw.SetHeader(tabVB, f'I={v0 / R:.5f}')

        # Sweep magnetic field
        for i, curr in enumerate(line_now):
            pw.SetHeader(tabVB, f'I={(v0 / R) / k_A:.5f} {core_units[k_A]}A, U={v0:.5f}, T={FormatTemperature(T)}')
            curr_curr = curr  # global variable to check current (and field) after program closes
            FieldUtils.SetField(Field_controller, curr)
            # print('Current:', curr)
            time.sleep(step_delay)

            curr_volt = Leonardo.MeasureNow(6) / gain  # in volts
            curr_field = FieldUtils.I_to_B(curr)

            if i < len(line_now) // 2:
                fieldValues_inc.append(curr_field)
                voltValues_inc.append(curr_volt / k_V_meas)  # in required units
                pw.updateScatter2D(tabVB, fieldValues_inc, voltValues_inc)
            else:
                fieldValues_dec.append(curr_field)
                voltValues_dec.append(curr_volt / k_V_meas)  # in required units
                pw.updateScatter2D(tabVB, fieldValues_dec, voltValues_dec)

            if f_exit.is_set():
                exit(0)

        # add data to common dictionary
        curr = (v0 / R) / k_A
        data_dict_inc[f'{curr:.5f}'] = copy(voltValues_inc)
        data_dict_dec[f'{curr:.5f}'] = copy(voltValues_dec)[::-1]

        # plot on common graph
        # plot without offset
        pw.plotOnScatter2D(tabVBForwardNoOffset, fieldValues_inc, voltValues_inc,
                           f'I={(v0 / R) / k_A:.3f} {core_units[k_A]}A', 'o', markersize=4)
        pw.SetHeader(tabVBForwardNoOffset, f'T={FormatTemperature(T)} mK')

        pw.plotOnScatter2D(tabVBReverseNoOffset, fieldValues_dec, voltValues_dec,
                           f'I={(v0 / R) / k_A:.3f} {core_units[k_A]}A', 'o', markersize=4)
        pw.SetHeader(tabVBReverseNoOffset, f'T={FormatTemperature(T)} mK')

        # offset implementation
        if k != 0:
            max_now = np.max(voltValues_inc)
            min_now = np.min(voltValues_inc)
            t = max((max_now - min_now), (max_pred_inc - min_pred_inc))
            distance = t * gap + (max_pred_inc - min_pred_inc)
            voltValues_inc += distance + curr_plot_bias_inc
            curr_plot_bias_inc += (max_now + distance)
            #
            max_now = np.max(voltValues_dec)
            min_now = np.min(voltValues_dec)
            t = max((max_now - min_now), (max_pred_dec - min_pred_dec))
            distance = t * gap + (max_pred_dec - min_pred_dec)
            voltValues_dec += distance + curr_plot_bias_dec
            curr_plot_bias_dec += (max_now + distance)

        # plot
        pw.plotOnScatter2D(tabVBForwardOffset, fieldValues_inc, voltValues_inc,
                           f'I={(v0 / R) / k_A:.3f} {core_units[k_A]}A', 'o', markersize=4)
        pw.SetHeader(tabVBForwardOffset, f'T={FormatTemperature(T)} mK')

        pw.plotOnScatter2D(tabVBReverseOffset, fieldValues_dec, voltValues_dec,
                           f'I={(v0 / R) / k_A:.3f} {core_units[k_A]}A', 'o', markersize=4)
        pw.SetHeader(tabVBReverseOffset, f'T={FormatTemperature(T)} mK')

        # offset algorithm part
        # save current values to calculate distance between this and the next curve
        min_pred_inc = np.min(voltValues_inc)
        max_pred_inc = np.max(voltValues_inc)

        min_pred_dec = np.min(voltValues_dec)
        max_pred_dec = np.max(voltValues_dec)

        time_mgr.OneSweepStepEnd(i + 1)

    # end for V
    EquipmentCleanup()
    f_exit.set()


def GetTemperatureThreadProc():
    global T
    T = LoadTemperatureFromLogs()


curr_curr = 0
gui_thread = threading.Thread(target=MainThreadProc)
gui_thread.start()

thermometer_thread = threading.Thread(target=GetTemperatureThreadProc)
thermometer_thread.start()

pw.show()  # show main tabbed window
f_exit.set()

# if exited before current returned to zero
FieldUtils.CheckAtExit(Field_controller, pw)

DataSave()
